FERRAMENTAS/BIBLIOTECAS PARA AJUDAR A PROGRAMAR OS NOSSOS PROJETOS:

	npm install --save-dev @types/node

	Ele cria a pasta chamada node_modules

	Por ser uma pasta pesada, não é recomendado subir ela para o repositório, pode excluir e rodar 
	o coomando "npm install" que ele vai ler as dependências do projeto incluídas no tsconfig e restaurar 
	os arquivos

SCRIPTS DO PACKAGE.JSON

	Podemos colocar dentro desse objeto, podemos colocar atalhos para executar comandos

ENTENDENDO IMPORT/EXPORT EM COMMONJS

	Existem duas formas de trabalhar com Import/Export

	MODOS DE IMPORTAÇÃO E EXPORTAÇÃO:

	IMPORTAÇÃO

		Clássico:

			const Object = require('./caminho');

		Moderno

			Import * as Object from './caminho'		(importa tudo)

			Import {function1, function2, function3} from './caminho'

			Import Object from './caminho'

	EXPORTAÇÃO

		Clássico:

			module.exports.function1 = function1
			module.exports.function2 = function2

		Moderno

			exports function function_name() {

			}

			export default Object_name {
				property1,
				property2,
				property3,
			}

IMPORTANDO ARQUIVOS TERCEIROS

	baixamos a biblioteca, digitando no terminal:

		npm install validator

	Depois importar

		import Validator from 'validator'

	Algumas bibliotecas disponiblizam a intalação para auxilios de tipos com o typescript

		npm install --save-dev @type/validator

CONHECENDO O NODEMON

	Biblioteca de monitoramento de arquivos, ao modificar um arquivo ela roda novamente,
	facilita para não termos que o código javascript toda vez que alteramos algo

USANDO NODEMON COM TYPESCRIPT

	Vamos agora diminuir a quantidade de terminais que usamos num projeto

	A partir de agora, ao invés de usarmos 2 terminais, vamos usar apenas um, com a biblioteca ts-node

	INSTALANDO

		npm install -g ts-node

	COMO USAR..

		Podemos usá-lo para rodar códigos typescript ao invés de javascript, co ts-node

			ts-node src/index.ts

	Porém ainda não é o que queremos! Precisamos de algo que faça o mesmo, porém monitorando as alterações
	feitas nos arquivos.

	Isso é possível com a nova versão do nodemon, use o comando:

		nodemon src/index.ts

			Quando o nodemon indentificar o arquivo typescript, ao invés de ele rodar o comando node,
			ele irá rodar o comando ts-node!

INSTALANDO O EXPRESS E CRIANDO UM SERVIDOR

	Express é uma biblioteca que nós conseguimos criar os nossos próprios servidores, em formato de arquivos typescript
	para controlar o gerenciamento da nossa aplicação, desde o controle da porta, até funcões globais do nosso sistema

	INSTALANDO...

		npm install express

	CÓDIGO DA AULA:

		import express, { Request, Response } from 'express';

		const server = express();

		server.get('/', (req: Request, res: Response) => {
				res.send('Olá Mundo');
		})

		server.listen(80);

TEORIA DAS ROTAS

	-- Definindo rotas
	server.get('/contato', (req: Request, res: Response) => {
		res.send('Esta é a página de contato');
	})

TRABALHANDO COM ROTAS

	Podemos utilizar os métodos GET, POST, PUT E DELETE nas nossas rotas
	
		// GET, POST, PUT, DELETE
		server.post('/', (req: Request, res: Response) => {
			res.send('Olá Mundo');
		})

	Separando dados na Url

	server.get('/noticia:slug', (req: Request, res: Response) => {
		let slug: string = req.params.slug;
		res.send(`Notícia: ${slug}`);
	});

	server.get('/voo/:origem-:destino', (req:Request, res:Response) => {
    	let { origem, destino } = req.params;

    	res.send(`Procurando voos de ${origem} até ${destino}`);
	});

SEPARANDO AS ROTAS NO SEU LUGAR

	Criamos uma pasta chamada Routes para organizar nossas ROTAS

	Para definirmos diferentes rotas no nosso projeto devemos no arquivo server.ts ter o seguinte:

		import express, { Request, Response } from 'express';
		import mainRoutes from './routes/index';
		import painelRoutes from './routes/painel';

		const server = express();

		server.use('/', mainRoutes);
		server.use('/painel', painelRoutes);

		server.listen(80);

CRIANDO O 404 (PÁGINA NÃO ENCONTRADA)

	Ao final das rotas se não for encontrado nada podemos...:

		server.use((req: Request, res: Response) => {
			res.status(404).send('Página não encontrada');
		})

	Para tratar o status 404

PASTA PÚBLICA E ARQUIVOS ESTÁTICOS

	Para acessarmos no navegador a pasta pública do nosso projeto 
	sem que tenho que definir uma rota programaticamente em server.ts, podemos adicionar o seguinte em server.ts:

		server.use(express.static('public'));

	Porém... dependendo de onde iniciarmos o nosso server.ts, seja na pasta c:/ ou c:/lucas/projetos/nodeJS/server.ts
	irá dar conflito, pois a estrutura das pastas é diferente. Para que a estrutura das pastas raiz seja fixa precisamos fazer o seguinte...

		import path from 'path';

		server.use(express.static(path.join(__dirname, '../public')));

		--__dirname é uma constante que especifica a pasta onde está o server.ts

INTRODUZINDO TEMPLATE ENGINES

	O template Engines nos permite retornar o arquivo html para as rotas que definimos no nosso server.ts

	Template Engines são bibliotecas, e existem vários:

		- Pug    (biblioteca remomendada pelo Express)  -- Não recomenado pelo Bonieky
		- mustache 										-- Remomendado pelo Bonieky
		- Edge											-- É um template Engine utilizado pelo AdonisJS que é um framework mais robusto que o Express
		- EJS (Embedded JavaScript templates)			

	Como a utilizamos?

		router.get('/', (req: Request, res: Response) => {
			//pegar os produtos do banco de dados
			//organizar as informações desses produtos
			//envia para o template engine
			res.send(index.html);
		});

INSTALANDO E CONFIGURANDO O MUSTACHE

	npm install mustache-express

	npm install --save-dev mustache-express

	Seguindo esses arquivos, você consegue entender os passos para renderizar o html utilizando o mustache

	IMPORTANTE...

		O nodemon não consegue monitorar arquivos com formato .mustache, apenas .ts e .JSON

		para isso precisamos alterar em package.json em start-dev e colocar o comando: -e ts,json,mustache

			nodemon -e ts,json,mustache src/server.ts

MUSTACHE: EXIBINDO INFORMAÇÕES

	Agora vamos trabalhar com variáveis no mustache, para isso, precisamos entender:

	RENDER

		ele tem 2 parâmetros principais

		O primeiro é nome do arquivo .mustache

		O segundo é um objeto com as informações que a gente quer enviar

MUSTACHE: EXIBIÇAO CONDICIONAL

	{{#showOld}}
        O {{name}} {{lastName}} é maior de idade
    {{/showOld}}

	Se o showOld for verdadeiro ele exibe a informação abaixo, se não não!

MUSTACHE: EXIBINDO LISTAS (LOOP)

	Percorrendo objetos:

		{{#products}}
            <li>{{ title }} - Preço: R$ {{ price }}</li>
        {{/products}}

		as propriedades dos objetos podemos acessar escrevendo o nome da sua propriedade, não precisando referenciar o objeto novamente

	Percorrendo vetores simples

		{{#tarefas}}
            <li>{{ . }}</li>
        {{/tarefas}}

		Coloque o ponto para acessar os valores do array

MUSTACHE: ELSE DE LISTAS

	Para utilizar o else basta trocar o jogo da velha (#) por ^

		{{^tarefas}}
            Nenhuma tarefa encontrada :)
        {{/tarefas}}

MUSTACHE: CONTEÚDO PARCIAL

	Você já sabe sobre esse CONTEÚDO, olha a sintaxe do código para relembrá-lo

	Só uma coisa, aqui não há necessidade de se passar a variável para o partial views, dependendo do contexto
	ele pode usar as variáveis do arquivo principal que o chamou

RECEBENDO DADOS NA URL 1

	Se enviarmos uma informação de um formulário com o método GET, ele atualiza a pagina e coloca as informações na Url

	Contudo, tudo que quisermos pegar de uma página por meio de requisições, devemos manipular o req: Request

	Tudo que vem depois do ponto de interrogação chama-se queryString, é possível pegar da seguinte forma:

		console.log('query string', req.query)

RECEBENDO DADOS VIA POST

	Antes de fazer isso, temos que configurar o arquivo server.ts

	Antes de adicionarmos as rotas no nosso servidor, temos que definir o seguinte código...

		server.use(express.urlencoded({extended: true}))

		Ele habilita o retorno do corpo da requisição POST, e permite manipular os dados contidos no body dentro da sua respectiva rota

INTRODUÇÃO À MVC

	--Já estudamos, siga o código

VARIÁVEIS DE AMBIENTE 

	É um arquivo sem e nome com extensão .env

	Ele guarda as variáveis de ambiente das nossas aplicações

	Conseguimos pegar a informação das portas por exemplo dentro desse arquivo

	Assim, dependendo do local em que estamos usando a aplicação, podemos usar portas diferentes com a mesma aplicação, porque o arquivo .env 
	vai estar em contextos diferentes

	Para conseguirmos pegar as informações contidas nele, precisamos...
	
		instalar uma biblioteca chamada dotEnv:

			npm install dotenv

		iniciar uma função chamada config():

			dotenv.config();

		Pegando...

			process.env.PORT
			// process é um objeto do node

	Podemos utilizar essa técnica para um banco de dados por exemplo...

MYSQL VS POSTGRESQL

	- Os ois são open-source, mas o Postgre é mais
	- Suportam todos* os SO e linguagens. * todos é uma generalição

	-- QUEM USA?

	-- MYSQL

	-- Facebook
	-- Google
	-- GitHub
	-- NASA
	-- NetFlix


	-- POSTGRESQL
	-- Apple
	-- Facebook
	-- Instagram
	-- Skype
	-- Spotify

	MYSQL não é case-sensitive
	PostgreSQL é case-sensitive

	---------- PERFORMANCE --------- 

	Geralmente para grandes volumes ou consultas complexas, 
	o PostgreeSQL tende a ser um pouco mais rápido.

	MYSQL geralmente é mais rápido para pequenos volumes OU consultas simples.

INSTALANDO LIB E CONFIGURANDO O UPLOAD

	Intalando:

		npm install multer

ENTENDENDO O QUE É CORS

	CORS: Cross-Origin Resource Sharing

	Troca de recursos de origens diferentes

	Qualquer sistema que faz requisições à outros sistemas, ele tem junto dele a origem da política do CORS

	Ela bloqueia, por padrão, que você faça requisições de uma url para outra url com o domínio diferente, a não ser que 
	no sistema que está sendo requisitado permita o acesso dos recursos aos sites/sistemas.

	Existem outros meios de bloqueiar os recursos... Como por exemplo permitir que apenas alguns métodos (GET, POST, PUT, DELETE ...) possam ser disponibilizados

	Get na maioria das vezes é permitido.

	O header (cabeçalho) para liberar uma origem, ou seja, um endereço para ele acessar o meu é O
	Access-Control-Align-Origin, e a política para liberar um método específico é o Access-Control-Align-Methods

	Prática:

		instalar a biblioteca CORS

			npm install cors
			npm install -D @types/cors

		importar o cors em server.ts

		Usá-lo em seguida ao iniciar o servidor:

			const server = express();

			server.use(cors());

		Podemos dentro da função cors, colocar um objeto com configurações específicas:

			server.use(cors({
				origin: 'https://resttesttest.com/',
				methods: ['GET', 'POST']
			}));

		Se não colocarmos, ele usa opções padrão:

			- que é liberar as funcionalidades para qualquer origem

BIBLIOTECAS DE UPLOAD MAIS USADAS

	- express-fileupload
	- Multer
	- formidable

	Escolhemos a Multer

INSTALANDO LIB E CONFIGURANDO O UPLOAD

	o Multer possui varias configurações, como por exemplo:

		dest: './tmp'		--define o destino

TIPOS DE STORAGE

	Podemos configurar o caminho e nome do arquivo com os comando em api.ts:

	const storageConfig = multer.diskStorage({
		destination: (req, file, cb) => {
			cb(null, './tmp');
		},
		filename: (req, file, cb) => {
			let typeExtension = (file.mimetype.slice(file.mimetype.indexOf('/')+1))
			cb(null, `${file.fieldname}${Date.now()}.${typeExtension}`);
		}
	});

	const upload = multer({
		storage: storageConfig

	});

	Podemos também definir uma configuração, para o arquivo ser recebido apenas com as suas informações, 
	sem armazenar em lugar Algum

	const upload = multer({
		storage: multer.memoryStorage()
	});

	ALERTA!

	Como o memoryStorage salva as informações dos arquivos na memória ram, corre o risco de o usuário derrubar o servidor,
	caso ele envie um arquivo muito grande no servidor.

VALIDANDO ARQUIVOS DE UPLOAD

	1 - Essa validação não fazemos no controlador. Mas fazemos isso antes de receber esse arquivo

	A validação dos arquivos é feito no método multer() em api.ts.

	criamos uma função chamada fileFilter no objeto que passamos para o método multer.

	essa função aceita três parâmetros, req, file, e cb

	cb é uma função, e aceita dois parâmetros, o primeiro, é para tratar erros, e o segundo o aceite do arquivo, uma variável
	do tipo boolean

	Função multer():

		const upload = multer({
			dest: './tmp',
			fileFilter: (req, file, cb) => {
				const allowed: string[] = ['image/jpg', 'image/jpeg', 'image/png']

				cb(null, allowed.includes(file.mimetype));
			}
		});

	2 - Também podemos filtrar os arquivos pelos seus tamanhos, sejam os conteúdos desses arquivos,
	seja o nome de uma imagem, e assim por diante...

	Para fazer isso precisamos de outro atributo no nosso objeto, chamado limits...

	Código:

		const upload = multer({
			dest: './tmp',
			fileFilter: (req, file, cb) => {
				const allowed: string[] = ['image/jpg', 'image/jpeg', 'image/png']

				cb(null, allowed.includes(file.mimetype));
			}
			limits: { fieldNameSize: 100, ... }
		});

	limits é um objeto que pode ser preenchido com seus atributos:

	O primeiro atributo é o fieldNameSize:

		Ele define o tamanho máximo em bytes dos nomes que os nossos
		arquivos podem ter, nesse caso o padrão são 100 bytes, que é 100 caracteres

	o segundo atributo é o fieldSize:

		Ele define o tamanho do conteúdo que o arquivo pode ter. Também colocamos ele em bytes

	Existem mais atributos, mas esses são os principais