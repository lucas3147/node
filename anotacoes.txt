FERRAMENTAS/BIBLIOTECAS PARA AJUDAR A PROGRAMAR OS NOSSOS PROJETOS:

	npm install --save-dev @types/node

	Ele cria a pasta chamada node_modules

	Por ser uma pasta pesada, não é recomendado subir ela para o repositório, pode excluir e rodar 
	o coomando "npm install" que ele vai ler as dependências do projeto incluídas no tsconfig e restaurar 
	os arquivos

SCRIPTS DO PACKAGE.JSON

	Podemos colocar dentro desse objeto, podemos colocar atalhos para executar comandos

ENTENDENDO IMPORT/EXPORT EM COMMONJS

	Existem duas formas de trabalhar com Import/Export

	MODOS DE IMPORTAÇÃO E EXPORTAÇÃO:

	IMPORTAÇÃO

		Clássico:

			const Object = require('./caminho');

		Moderno

			Import * as Object from './caminho'		(importa tudo)

			Import {function1, function2, function3} from './caminho'

			Import Object from './caminho'

	EXPORTAÇÃO

		Clássico:

			module.exports.function1 = function1
			module.exports.function2 = function2

		Moderno

			exports function function_name() {

			}

			export default Object_name {
				property1,
				property2,
				property3,
			}

IMPORTANDO ARQUIVOS TERCEIROS

	baixamos a biblioteca, digitando no terminal:

		npm install validator

	Depois importar

		import Validator from 'validator'

	Algumas bibliotecas disponiblizam a intalação para auxilios de tipos com o typescript

		npm install --save-dev @type/validator

CONHECENDO O NODEMON

	Biblioteca de monitoramento de arquivos, ao modificar um arquivo ela roda novamente,
	facilita para não termos que o código javascript toda vez que alteramos algo

USANDO NODEMON COM TYPESCRIPT

	Vamos agora diminuir a quantidade de terminais que usamos num projeto

	A partir de agora, ao invés de usarmos 2 terminais, vamos usar apenas um, com a biblioteca ts-node

	INSTALANDO

		npm install -g ts-node

	COMO USAR..

		Podemos usá-lo para rodar códigos typescript ao invés de javascript, co ts-node

			ts-node src/index.ts

	Porém ainda não é o que queremos! Precisamos de algo que faça o mesmo, porém monitorando as alterações
	feitas nos arquivos.

	Isso é possível com a nova versão do nodemon, use o comando:

		nodemon src/index.ts

			Quando o nodemon indentificar o arquivo typescript, ao invés de ele rodar o comando node,
			ele irá rodar o comando ts-node!

INSTALANDO O EXPRESS E CRIANDO UM SERVIDOR

	Express é uma biblioteca que nós conseguimos criar os nossos próprios servidores, em formato de arquivos typescript
	para controlar o gerenciamento da nossa aplicação, desde o controle da porta, até funcões globais do nosso sistema

	INSTALANDO...

		npm install express

	CÓDIGO DA AULA:

		import express, { Request, Response } from 'express';

		const server = express();

		server.get('/', (req: Request, res: Response) => {
				res.send('Olá Mundo');
		})

		server.listen(80);

TEORIA DAS ROTAS

	-- Definindo rotas
	server.get('/contato', (req: Request, res: Response) => {
		res.send('Esta é a página de contato');
	})

TRABALHANDO COM ROTAS

	Podemos utilizar os métodos GET, POST, PUT E DELETE nas nossas rotas
	
		// GET, POST, PUT, DELETE
		server.post('/', (req: Request, res: Response) => {
			res.send('Olá Mundo');
		})

	Separando dados na Url

	server.get('/noticia:slug', (req: Request, res: Response) => {
		let slug: string = req.params.slug;
		res.send(`Notícia: ${slug}`);
	});

	server.get('/voo/:origem-:destino', (req:Request, res:Response) => {
    	let { origem, destino } = req.params;

    	res.send(`Procurando voos de ${origem} até ${destino}`);
	});

SEPARANDO AS ROTAS NO SEU LUGAR

	Criamos uma pasta chamada Routes para organizar nossas ROTAS

	Para definirmos diferentes rotas no nosso projeto devemos no arquivo server.ts ter o seguinte:

		import express, { Request, Response } from 'express';
		import mainRoutes from './routes/index';
		import painelRoutes from './routes/painel';

		const server = express();

		server.use('/', mainRoutes);
		server.use('/painel', painelRoutes);

		server.listen(80);

CRIANDO O 404 (PÁGINA NÃO ENCONTRADA)

	Ao final das rotas se não for encontrado nada podemos...:

		server.use((req: Request, res: Response) => {
			res.status(404).send('Página não encontrada');
		})

	Para tratar o status 404

PASTA PÚBLICA E ARQUIVOS ESTÁTICOS

	Para acessarmos no navegador a pasta pública do nosso projeto 
	sem que tenho que definir uma rota programaticamente em server.ts, podemos adicionar o seguinte em server.ts:

		server.use(express.static('public'));

	Porém... dependendo de onde iniciarmos o nosso server.ts, seja na pasta c:/ ou c:/lucas/projetos/nodeJS/server.ts
	irá dar conflito, pois a estrutura das pastas é diferente. Para que a estrutura das pastas raiz seja fixa precisamos fazer o seguinte...

		import path from 'path';

		server.use(express.static(path.join(__dirname, '../public')));

		--__dirname é uma constante que especifica a pasta onde está o server.ts

INTRODUZINDO TEMPLATE ENGINES

	O template Engines nos permite retornar o arquivo html para as rotas que definimos no nosso server.ts

	Template Engines são bibliotecas, e existem vários:

		- Pug    (biblioteca remomendada pelo Express)  -- Não recomenado pelo Bonieky
		- mustache 										-- Remomendado pelo Bonieky
		- Edge											-- É um template Engine utilizado pelo AdonisJS que é um framework mais robusto que o Express
		- EJS (Embedded JavaScript templates)			

	Como a utilizamos?

		router.get('/', (req: Request, res: Response) => {
			//pegar os produtos do banco de dados
			//organizar as informações desses produtos
			//envia para o template engine
			res.send(index.html);
		});

INSTALANDO E CONFIGURANDO O MUSTACHE

	npm install mustache-express

	npm install --save-dev mustache-express

	Seguindo esses arquivos, você consegue entender os passos para renderizar o html utilizando o mustache

	IMPORTANTE...

		O nodemon não consegue monitorar arquivos com formato .mustache, apenas .ts e .JSON

		para isso precisamos alterar em package.json em start-dev e colocar o comando: -e ts,json,mustache

			nodemon -e ts,json,mustache src/server.ts

MUSTACHE: EXIBINDO INFORMAÇÕES

	Agora vamos trabalhar com variáveis no mustache, para isso, precisamos entender:

	RENDER

		ele tem 2 parâmetros principais

		O primeiro é nome do arquivo .mustache

		O segundo é um objeto com as informações que a gente quer enviar

MUSTACHE: EXIBIÇAO CONDICIONAL

	{{#showOld}}
        O {{name}} {{lastName}} é maior de idade
    {{/showOld}}

	Se o showOld for verdadeiro ele exibe a informação abaixo, se não não!

MUSTACHE: EXIBINDO LISTAS (LOOP)

	Percorrendo objetos:

		{{#products}}
            <li>{{ title }} - Preço: R$ {{ price }}</li>
        {{/products}}

		as propriedades dos objetos podemos acessar escrevendo o nome da sua propriedade, não precisando referenciar o objeto novamente

	Percorrendo vetores simples

		{{#tarefas}}
            <li>{{ . }}</li>
        {{/tarefas}}

		Coloque o ponto para acessar os valores do array

MUSTACHE: ELSE DE LISTAS

	Para utilizar o else basta trocar o jogo da velha (#) por ^

		{{^tarefas}}
            Nenhuma tarefa encontrada :)
        {{/tarefas}}

MUSTACHE: CONTEÚDO PARCIAL

	Você já sabe sobre esse CONTEÚDO, olha a sintaxe do código para relembrá-lo

	Só uma coisa, aqui não há necessidade de se passar a variável para o partial views, dependendo do contexto
	ele pode usar as variáveis do arquivo principal que o chamou

RECEBENDO DADOS NA URL 1

	Se enviarmos uma informação de um formulário com o método GET, ele atualiza a pagina e coloca as informações na Url

	Contudo, tudo que quisermos pegar de uma página por meio de requisições, devemos manipular o req: Request

	Tudo que vem depois do ponto de interrogação chama-se queryString, é possível pegar da seguinte forma:

		console.log('query string', req.query)

